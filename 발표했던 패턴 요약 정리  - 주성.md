## 지금 까지 발표했던 패턴들 내용 요약 정리

- **프로토타입 패턴**
- **컴포지트 패턴**
- **전략 패턴**
- **이터레이터 패턴**

# **생성(Creational) 패턴**

**객체를 생성, 합성하는 방법이나 객체의 표현 방법을 시스템과 분리한다**

→ 생성이 복잡하거나, 생성에 대한 의존성을 줄이고 싶을 때

## **프로토타입** (**Prototype) 패턴**

### **정의**

✅ **Prototype pattern**은 **코드를 그들의 클래스들에 의존시키지 않고 기존 객체들을 복사할 수 있도록 하는 생성 디자인 패턴**

<img src="https://refactoring.guru/images/patterns/content/prototype/prototype.png">

→ 즉, 인스턴스가 **`내부적`**으로 자신을 복제한 **`새로운`** 인스턴스(**`자신과 같은 값을 가진`**)를 제공하는 패턴

### **`디자인 패턴 목적(문제 해결)`**

- 객체의 필드들 중 일부가 **`비공개`** 여서 객체 자체의 외부에서 볼 수 없을 때
- **`의존성`** 을 줄이고 싶을 때  → 객체의 복제본을 생성하기 위해서는 객체의 클래스를 알아야 한다.
- 메서드의 매개변수가 인터페이스이어서 복제하고자 하는 객체의 **`구상(구체) 클래스에 대해 알 수 없을 때`**

### **`다른 패턴과 비교`**

- 많은 디자인(생성 패턴을 사용하는)이 **팩토리 메서드**로 시작해 더 유연하면서도 더 복잡한 **추상 팩토리**, **프로토타입** 또는 **빌더** 패턴으로 발전해 나갑니다. 
→ 복잡성이 낮고 자식 클래스들을 통해 더 많은 커스터마이징이 가능하기 때문에
- **프로토타입**을 사용하여 **추상 팩토리**의 구상 클래스들의 생성 메서드들을 구현할 수도 있다.
- **프로토타입**은 **커맨드** 패턴의 복사본들을 기록에 저장해야 할 때 도움이 될 수 있다.
- **데코레이터** 및 **컴포지트** 패턴을 많이 사용하는 디자인에서 **프로토타입**을 사용하면 편리하게 구현할 수도 있다. 
→ 복잡한 구조들을 처음부터 다시 구현하는 대신 복제해서 사용하면 되기 때문에
- **프로토타입**은 상속과 관련된 단점들이 없는 대신, 복제된 객체의 복잡한 초기화가 필요하다. 그에 반해 **팩토리 메서드**는 상속을 기반으로 하지만 초기화 단계가 필요하지 않습니다.
- 때로는 **프로토타입**이 **메멘토** 패턴의 더 간단한 대안이 될 수 있다.
- **추상 팩토리들**, **빌더들** 및 **프로토타입들**은 모두 **싱글턴**으로 구현할 수 있습니다.

### **`어디에 쓰이는지(예제)`**

- 자바 Object 클래스의 **`clone()`** 메소드와 **`Cloneable`** 인터페이스
- ModelMapper 라이브러리
- List<T> clone = new ArrayList<>(복사를 원하는 리스트); (프로토 타입과는 다소 무관)

# **구조(Structual) 패턴**

**객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공한다 (객체들 간의 관계를 어떤 구조로 만들 것이냐..)**

## **컴포지트(Composite) 패턴**

### **`정의`**

✅ ***Composite pattern*은 객체들을 트리 구조들로 구성한 후, 이러한 구조들과 개별 객체들처럼 작업할 수 있도록 하는 구조 패턴**

<img src="https://refactoring.guru/images/patterns/diagrams/composite/problem-ko.png">

→ **`단일 객체`** 와 **`복합 객체`** 를 **`같은 타입으로 취급`** 하여  객체들 간의 관계를 **`트리 구조`** 로 구성할 수 있는 패턴 

### **`디자인 패턴 목적(문제 해결)`**

- 단순 요소들과 복합 요소들을 **`모두 균일한 처리`** 가 필요할 때 → 상자와 물건의 가격을 다 더해야 하는 상황 → 구상 클래스에 대해 일일이 알고 싶지 않은 경우
- 전체-부분( 혹은 계층)의 관계(Ex. Directory-File)를 갖는 객체들 사이의 관계를 정의(표현)하고 싶을 때

### **`다른 패턴과 비교`**

- 복잡한 **복합체** 패턴 트리를 생성할 때 **빌더**를 사용할 수 있다.
- **책임 연쇄** 패턴은 종종 **복합체** 패턴과 함께 사용된다.
    
    → 그러면 잎 컴포넌트가 요청을 받으면 해당 요청을 모든 부모 컴포넌트들의 체인을 통해 객체 트리의 뿌리(root)까지 전달할 수 있다.
    
- **반복자**를 사용하여 **복합체** 패턴 트리들을 순회할 수 있습니다.
- **비지터** 패턴을 사용하여 **복합체** 패턴 트리 전체를 대상으로 작업을 수행할 수 있다.
- RAM을 절약하기 위하여 **복합체** 패턴 트리의 공유된 잎 노드들을 **플라이웨이트들**로 구현할 수 있다.
- **복합체** 패턴 및 **데코레이터**는 둘 다 구조 다이어그램이 유사하다.
    
     → 왜냐하면 둘 다 재귀적인 합성에 의존하여 하나 또는 불특정 다수의 객체들을 정리한다.
    
    → **데코레이터**는 자식 컴포넌트가 하나만 있다. 또 다른 중요한 차이점은 데코레이터는 래핑된 객체에 추가 책임들을 추가하는 반면 복합체 패턴은 자신의 자식들의 결과를 **`요약`** 하기만 한다. 데코레이터를 사용하여 복합체 패턴 트리의 특정 객체의 행동을 확장할 수도 있다.
    

### **`어디에 쓰이는지(예제)`**

- Java **`Swing`** 라이브러리(GUI)
    
    → **JFrame, JTextField, JButton** 이 3개의 객체는 전부 **Component** 라는 추상 클래스를 상속받는다 ⇒ **Component**를 상속하는 객체들을 리스트로 가지고 있다
    

# **행동(Behavioral) 패턴**

**한 객체가 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하며 객체 사이의 결합도 최소화한다**

## **전략(Strategy) 패턴**

### **`정의`**
  <img src="https://refactoring.guru/images/patterns/content/strategy/strategy.png">

✅ **Strategy pattern** 은 **유사한  **`알고리즘들을 캡슐화`** 하여, 실행 중에 **`상호 교환`** 할 수 있도록 하는 행동 패턴**

→ 로직이 자주 변경 되는 곳을 **`추상화`** 하여, 동적으로 **`로직을 주입`** 받을 수 있게한 패턴

### **`디자인 패턴 목적(문제 해결)`**

- 알고리즘(전략, 로직)이 자주 **`변경`** 되는 경우
- **`런타임`** 에 알고리즘을 변경해야 하는 경우
- 상속 대신 **`구현`** 을 사용해야 하는 경우
- 알고리즘의 일부가 **`중복`** 되는 경우

### **`다른 패턴과 비교`**

- **브리지**, **상태**, **전략, 어댑터** 패턴은 유사한 구조로 되어 있다. → 해결하려는 문제가 다름
- **커맨드**와 **전략** **패턴**은 비슷해 보일 수 있다.
    
    → 어떤 작업으로 객체를 매개변수화하는 데 사용할 수 있기 때문
    
    - **커맨드 패턴**를 사용하여 모든 작업을 객체로 변환할 수 있다. 작업의 매개변수들은 해당 객체의 필드들이 된다. 이 변환은 작업의 실행을 연기하고, 해당 작업을 대기열에 넣고, 커맨드들의 기록을 저장한 후 해당 커맨드들을 원격 서비스에 보내는 등의 작업을 가능하게 한다. →  각각 다른 알고리즘
    - 반면에 **전략 패턴**은 일반적으로 같은 작업을 수행하는 다양한 방법을 설명하므로 단일 콘텍스트 클래스 내에서 이러한 알고리즘들을 교환할 수 있다. → 유사한 알고리즘
- **데코레이터**는 객체의 외부(결과 값)을 변경할 수 있고, **전략**은 객체의 내부 알고리즘을 변경한다.
- **템플릿 메서드**와 **전략** **패턴**은 같은 문제를 다른 방식으로 해결한다
    - **템플릿 메서드**는 상속을 기반으로 한다. 이 메서드는 자식 클래스들에서 알고리즘의 부분들을 확장하여 변경할 수 있도록 한다.
    - 반면에 **전략** **패턴**은 합성을 기반으로 한다. 당신은 객체 행동의 일부분들을 이러한 행동에 해당하는 다양한 전략들을 제공하여 변경할 수 있다.
    - **템플릿 메서드**는 클래스 수준에서 작동하므로 정적인데 반해 **전략 패턴**은 객체 수준에서 작동하므로 런타임에 행동들을 전환할 수 있다.
- **상태**는 **전략**의 확장으로 간주할 수 있다.
    
    → 두 패턴 모두 합성을 기반으로 하고, 특정 작업을 도우미 객체들에 전달하여 콘텍스트의 행동을 바꾼다. 
    
    - **전략 패턴**은 이러한 객체들을 완전히 독립적으로 만들어 서로를 인식하지 못하도록 만드는다
    - 반면에 **상태 패턴**은 구상 상태들 사이의 의존 관계들을 제한하지 않으므로 그들이 콘텍스트의 상태를 마음대로 변경할 수 있도록 한다.

### **`어디에 쓰이는지(예제)`**

- Java **`Comparator`**
- Spring에서 인터페이스를 사용한 대다수의 경우 → Spring Boot AutoCofing, Security 예제

## **이터레이터(Iterator) 패턴**

### **정의**
  
<img src="https://refactoring.guru/images/patterns/diagrams/iterator/problem2.png">

✅ ***Iterator pattern은* `컬렉션`의 요소들의 기본 표현(리스트, 스택, 트리 등)을 `노출하지 않고` 그들을 하나씩 `순회`할 수 있도록 하는 행동 디자인 패턴입니다.**

→ 컬렉션 **`구현 방법을 노출시키지 않으면서도`** 그 집합체안에 들어있는 **`모든 항목에 접근`** 할 수 있게 해 주는 방법을 제공해 주는 패턴 

### **`디자인 패턴 목적(문제 해결)`**

- 집합 객체 내부에 복잡한 데이터 구조가 있지만 보안이나 편의상의 이유로 **`숨기고 싶을 때`**
- 순회 코드의 **`중복`** 이 있는 경우
- 컬렉션의 구조 유형을 미리 **`알지 못하는 상황`** 에서 데이터를 순회하길 원할 때

### **`다른 패턴과 비교`**

- **반복자들**을 사용하여 **복합체** 패턴 트리들을 순회할 수 있다.
- **팩토리 메서드**를 **반복자**와 함께 사용하여 컬렉션 자식 클래스들이 해당 컬렉션들과 호환되는 다양한 유형의 반복자들을 반환하도록 할 수 있다.
- **메멘토** 패턴을 **반복자** 패턴과 함께 사용하여 현재 순회 상태를 포착하고 필요한 경우 롤백할 수 있다.
- **비지터** 패턴과 **반복자** 패턴을 함께 사용해 복잡한 데이터 구조를 순회하여 해당 구조의 요소들의 클래스들이 모두 다르더라도 이러한 요소들에 대해 어떤 작업을 실행할 수 있다.

### **`어디에 쓰이는지(예제)`**

- Java `Enumeration` 와 **`Iterator`**
- Java `StAX (Streaming API for XML)` →  XML를 읽을 수 있는 Iterator를 제공
- Spring의 `CompositeIterator`  → Iterator를 조합할 수 있는 메서드 제공
- JDBC → ResultSet ? / Wrapping 해서 제공한다면?

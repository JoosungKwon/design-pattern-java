

# 템플릿 메소드 패턴



템플릿의 사전적 의미 : 본 또는 틀 이라는 의미를 가지고 있습니다.



템플릿 메서드 패턴은 생성, 구조, 행위 패턴중에 행위 패턴 중에 속합니다 .

행위 패턴은 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴입니다.



정의 :

슈퍼(부모 클래스)에서 알고리즘의 구조를 정의하지만, 

해당 알고리즘의 구조를 변경하지 않고 

서브(자식 클래스)들이 알고리즘의 특정 단계들을 오버라이드(재정의)할 수 있도록 하는 행동 디자인 패턴

**알고리즘이 단계별로 나누어 지거나, 같은 역할을 하는 메소드이지만 여러곳에서 다른형태로 사용이 필요한 경우 유용한 패턴입니다.**



토비의 스프링에서는 이렇게 정의합니다.

**상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법.**

** 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.** 



Template Method는 보통 상속 기반의 프레임워크에서 사용됩니다. 



프레임워크는 작업의 90% 정도를 기반 클래스를 통해 제공하며, 

애플리케이션에 용도에 맞게 맞춤화할 필요가 있는 부분은 추상 메소드로 남겨놓습니다. 

사용자는 클래스를 상속하고 추상 메소드를 필요에 맞게 구현함으로써 프레임워크를 사용하게 됩니다.



## 이 패턴을 사용하는 이유.

프로세스가 있는 특정한 로직을 구현하려고 하는데, 이 로직이 상황에 따라 바뀌게 됐을 때 중복을 줄이기 위해 사용할 수 있습니다.

비슷한 동작을 하는 객체들에게, 변하지 않는 부분을  정의해 놓고

변경 가능성이 있는 부분은 하위 클래스에 서 구현할 수 있게 템플릿 메소드 패턴을 이용하면

**코드의 중복을 피할 수 있고** 상위 클래스로 묶여있기 때문에 **if - else 문을 쓰지 않고 다양한 객체를 생성**할 수 있습니다.



![image-20221027194726694](/Users/ysk/study/devcourse/dev_course_BE/디자인패턴/images//image-20221027194726694.png)

## 팩토리 메소드의 구성 단계

1. 알고리즘(요구사항)을 여러 단계로 나눈다
2. 나눠진 알고리즘의 단계를 메소드로 선언한다. 
   * 이 메소드를 훅 메소드 라고 한다. **아무 일도 하지 않거나 기본 행동을 정의하는 메소드**이며 오버라이딩 할 수 있다.
3. 알고리즘을 수행할 템플릿 메소드를 만든다.
   * 템플릿 메소드 내에서 단계대로 호출한다.
4. 하위클래스에서 나눠진 메소드들을 구현한다. 





## 구현 방법

- 공통점을 뽑아내어 추상 클래스를 선언한다.
- 추상 클래스에 핵심 기능인 팩토리 메소드를 만들고,  자주 변경되며 확장할 기능들인 훅 메소드들은 추상메소드로 만들어 서브클래스에서 확장할 수 있도록 한다. 
  - 이때 추상메소드로 만들어도 되고, 간단한 기능만을 정의해도 된다. 


* 훅 메소드들을 팩토리 메소드 내에서 호출한다.
* 같은 동작을 하는 서브클래스들을 생성하여 추상클래스를 상속받고 오버라이딩 하여 사용한다. 



### 예제

다음은 커피와 차를 클래스로 설계하고 레시피를 준비하는 동작을 구현한 내용입니다.



```java
public class Coffee {
  public void prepareRecipe() { // 레시피 준비. 
    boilWater();				// 물을 끓이고
    brewCoffeeGrinds();	// 커피 원두를 갈고
    pourInCup();				// 컵에 담는다.
    addSugarAndMilk();	// 설탕과 우유를 추가한다.
  }
  
  public void boilWater() {...}
  public void brewCoffeeGrinds(){...}
  public void pourInCup(){...}
  public void addSugarAndMilk(){...}
 
}

public class Coffee {
  public void prepareRecipe() {
    boilWater();				// 물을 끓이고
    steepTeaBag();			// 커피 원두를 갈고
    pourInCup();				// 컵에 담는다.
    addLemon();					// 레몬을 추가한다
  }
  
  public void boilWater() {...}
  public void steepTeaBag(){...}
  public void pourInCup(){...}
  public void addLemon(){...}
 
}
```



예를들어, 커피를 준비하려면 카페 직원 입장에서는  

1. 물을 끓여야 하고
2. 원두를 우려낸다음

3. 컵에 커피를 넣고
4. 시럽이든 설탕을 넣고
5. 커피를 준비



마찬가지로 티를 준비하려면

1. 물을 끓여야 하고
2. 차를 우려낸다음
3. 컵에 넣고
4. 레몬이든 다른 첨가물을 넣고
5. 티를 준비



어떤가요? 둘의 과정이 매우 비슷하지 않나요? 

이 과정은 원두를우려내는 과정을 구현한  `brewCoffeeGrinds()` 와 차를 우려내는 과정을 구현한`steepTeaBag()`, 

그리고 설탕과 우유를 추가하는 `addSugarAndMilk()`과  레몬을 추가하는 `addLemon()` 는 다른 과정이지만 순서는 같고,

 공통적으로 1. 물을 끓이고 3. 컵에 넣고 5. 전달하는  과정이 겹치게 됩니다.

그러면 2번 과정과 4번 과정을 추상화 할 수 있게 됩니다.



이 모든 동작들을 추상화해서 템플릿을 만들 수 있게되고,

음료라는 추상 클래스를 선언해서 커피랑 티는 이 추상클래스를 상속받아 우려내는 과정과 첨가물을 넣는 과정의

추상 메소드만 구현하게 되면, 레시피를 준비하는 과정을 사용해도 각기 다르므로 다형성을 구현할 수 있습니다.



```java
abstract class Beverage {

    final void prepareRecipe() { // 알고리즘을 갖고 있는 이 메소드를 '템플릿 메소드'라 부른다
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    abstract void brew();           // 서브클래스에서 구현

    abstract void addCondiments();  // 서브클래스에서 구현

    void boilWater() {
        System.out.println("물 끓이는 중");
    }

    void pourInCup() {
        System.out.println("컵에 따르는 중");
    }

}

class Coffee extends Beverage {
    public void brew() {
        System.out.println("필터로 커피를 우려내는 중");
    }

    public void addCondiments() {
        System.out.println("설탕과 커피를 추가하는 중");
    }
}

class Tea extends Beverage {
    public void brew() {
        System.out.println("차를 우려내는 중");
    }

    public void addCondiments() {
        System.out.println("레몬을 추가하는 중");
    }
}

public class Main {
    public static void main(String[] args) {

        Beverage coffee = new Coffee();
        coffee.prepareRecipe();
        System.out.println("--------------------------");
        Beverage tea = new Tea();
        tea.prepareRecipe();
    }
}
```



* 공통적인 부분을 뽑아 추상 클래스를 만든다
* 알고리즘에서 차이가 있는 곳은 추상 메소드로 정의한다 - prepareRecipe 메소드의 brew 메소드와 pourInCup 메소드



- 장점

  - 중복된 코드를 없애고 SubClass 에서는 비즈니스 로직에만 집중할 수 있음 (SRP)

  - 알고리즘의 처리 과정은 변경하지 않고 각 단계의 처리를 서브클래스에서 재정의할 수 있어 

    의존 역전 원칙에 따라 구체적인 것이 아니라 추성적인 것에 의존하는 설계를 할 수 있다.

  - 나중에 새로운 비즈니스 로직이 추가되어도 기존 코드를 수정하지 않아도 됨 (OCP)

  * 새 하위클래스가 추가되더라도 기존 코드를 변경할 필요가 없으므로  결과적으로 결합도가 낮아지면서 **유지보수**에 용이



- 단점
  - 클래스 파일을 계속 만들어야 함
  - 자식 클래스는 실제로 부모 클래스를 사용하지 않는데 단순히 패턴 구현을 위한 상속 때문에 의존 관계를 갖고 있음
  - 상위 클래스가 관리하는 하위 클래스가 많을 때, 상위 클래스를 수정하게 된다면, **모든 하위 클래스들을 일일히 수정**해야 하는 상황이 발생함.





### 서브클래스가 템플릿 메소드를 맘대로 오버라이딩 해서 수정할 수도 있는거 아닌가요?



템플릿 메서드를 final로 선언해 서브클래스가 실수로 오버라이드하는 것을 예방할 수도 있습니다.

단, 이런 방법은 클라이언트 코드에서 템플릿 메서드의 불변적인 부분을 전혀 변경할 필요가 없는 것이 확실할 때에만 사용해야 합니다. 



### 추상 클래스 말고도 자바 8에서 인터페이스 디폴트 메소드로 템플릿 메소드 패턴을 구현할 수 있지 않나요?



인터페이스 같은경우 디폴트 메소드는 final로 정의를 할수없어 재정의는 가능하지만,

모든 메소드가 public abstract 이므로 인터페이스일 경우, 외부에는 숨겨두고 템플릿 메소드에서 호출되어야 만 하는 기능(메소드)들이

public 제어자에 의해 의도치 않게 호출될 수 있으므로 템플릿 메소드 패턴을 만들 수 없습니다.







### 참고

https://www.youtube.com/watch?v=mnjIEAMWpfk

https://joeylee.tistory.com/21
